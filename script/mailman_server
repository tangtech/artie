require "rubygems"
require "bundler/setup"
require "mailman"
require "nokogiri"
require "net/smtp"

require File.dirname(__FILE__) + "/../config/environment"
Mailman.config.ignore_stdin = true

Mailman.config.pop3 = {
    server: 'pop.gmail.com', port: 995, ssl: true,
    username: GMAIL_USERNAME,
    password: GMAIL_PASSWORD
}

SENDER_EMAIL_REGEX = /From:.*[\w+\-.]+@[a-z\d\-.]+\.[a-z]+/i

Mailman::Application.run do
  default do
    begin
      # Extract email body & sender
      the_message_html = (message.multipart? ? message.html_part.body.decoded.force_encoding("ISO-8859-1").encode("UTF-8")  : message.body.decoded.force_encoding("ISO-8859-1").encode("UTF-8"))
      the_message_text = (message.multipart? ? message.text_part.body.decoded.force_encoding("ISO-8859-1").encode("UTF-8")  : message.body.decoded.force_encoding("ISO-8859-1").encode("UTF-8"))
      the_message_sender = message.from.first

      # If email sender does not match a customer domain...
      if Customer.where(:domain => message.from.first.split("@")[1]).count == 0
        # Regex match who has forwarded it...
        # Note: This Regex ONLY matches the formatting used in Gmail's 'Forward', not 'Reply'
        this_message_sender_matches = the_message_text.scan(SENDER_EMAIL_REGEX)
        # And loop until (i) we get a match or (ii) run out of matches
        i = 0
        while the_message_sender == message.from.first && !this_message_sender_matches[i].nil? do
          the_message_sender = this_message_sender_matches[i].to_s.split("<")[1] if Customer.where(:domain => this_message_sender_matches[i].to_s.split("@")[1]).count > 0
          i += 1
        end
      end

      # Only add to our database if a valid customer is identified
      if Customer.where(:domain => the_message_sender.split("@")[1]).count > 0
        @incoming_rfq = IncomingRfq.create(:from => the_message_sender, :subject => message.subject, :html_body => the_message_html, :text_body => the_message_text)

        # Extract and save attachments
        if message.multipart?
          message.attachments.each do |attachment|
            file = StringIO.new(attachment.decoded)
            file.class.class_eval { attr_accessor :original_filename, :content_type }
            file.original_filename = attachment.filename
            file.content_type = attachment.mime_type
            # Our system can only handle TXT and PDF file formats for now
            if file.content_type == "text/plain" || file.content_type == "application/pdf"
              incoming_rfq_attachment = IncomingRfqAttachment.new
              incoming_rfq_attachment.attached_file = file
              incoming_rfq_attachment.incoming_rfq_id = @incoming_rfq.id
              incoming_rfq_attachment.save
            end
          end
        end

        # Extract list of items from HTML table in email
        # This only works for the Aker Batam BO format
        # KIV extract to another file and called dynamically after introducing functionality for other customer formats
        doc = Nokogiri::HTML(the_message_html)
        table = doc.at('table')
        this_table = []
        table.search('tr').each do |tr|
          this_row = []
          tr.search('td').each do |td|
            this_row << td.text.strip
          end
          this_table << this_row
        end

        # Get indices for :part_number, :description, :quantity, :required_delivery_date
        index_part_number = this_table[0].index("Material")
        index_description = this_table[0].index("Short Text")
        index_quantity = this_table[0].index("Qty")
        index_required_delivery_date = this_table[0].index("Delivery")
        this_table.shift

        # Store :part_number, :required_delivery_date in arrays
        get_all_dates = []
        get_all_part_numbers = []
        this_table.each do |row|
          get_all_dates << row[index_required_delivery_date]
          get_all_part_numbers << row[index_part_number]
        end

        # Check if :required_delivery_date is formatted DD/MM/YYYY or MM/DD/YYYY
        get_valid_dates = get_all_dates.select { |date| Date.parse(date) rescue nil }
        incoming_rfq_american_date = (get_all_dates.count != get_valid_dates.count ? true : nil)

        # Get unique :part_number...
        get_valid_part_numbers  = get_all_part_numbers.uniq
        get_valid_part_numbers.each do |part_number|
          incoming_rfq_item = IncomingRfqItem.new
          incoming_rfq_item.incoming_rfq_id = @incoming_rfq.id
          incoming_rfq_item.part_number = part_number
          incoming_rfq_item.quantity = 0
          this_table.each do |row|
            # And match :description, :quantity, :required_delivery_date
            if part_number == row[index_part_number]
              incoming_rfq_item.quantity += row[index_quantity].to_i
              incoming_rfq_item.description = row[index_description]
              this_date = (incoming_rfq_american_date.nil? ? Date.strptime(row[index_required_delivery_date], "%d/%m/%Y") : Date.strptime(row[index_required_delivery_date], "%m/%d/%Y"))
              incoming_rfq_item.required_delivery_date = this_date if incoming_rfq_item.required_delivery_date.nil? || incoming_rfq_item.required_delivery_date > this_date
            end
          end
          puts incoming_rfq_item.inspect
          incoming_rfq_item.save
        end

      # Else, send an error email if cannot upload
      else
        email_body = <<END_OF_MESSAGE
From: New RFQ Uploader <new.rfq@tangtechnical.com>
To: <#{message.from.first}>
Subject: Error Uploading #{message.subject}
Your Email #{message.subject} could not be uploaded.
END_OF_MESSAGE

        smtp = Net::SMTP.new 'smtp.gmail.com', 587
        smtp.enable_starttls
        smtp.start('gmail.com', GMAIL_USERNAME, GMAIL_PASSWORD, :login)
        smtp.send_message email_body, 'new.rfq@tangtechnical.com', message.from.first
        smtp.finish
      end

    rescue Exception => e
      Mailman.logger.error "Exception occurred while receiving message:\n#{message}"
      Mailman.logger.error [e, *e.backtrace].join("\n")
    end
  end
end
